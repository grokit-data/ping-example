/// <reference types="node" />
import * as stream from 'stream';

declare class Int {
}
declare class Void {
}
declare class JsonValue {
}
declare class Requester extends String {
}

interface UiCard {
    type: 'AdaptiveCard';
    "$schema"?: string;
    "version": string;
    body: object[];
}
interface AgentDefinition {
    cls: string;
    cnstr: Function;
    base: string | null;
    options: AgentOptions;
}
interface AgentOptions {
    subject?: string;
    status?: Function[];
    singleton?: boolean;
    sessions?: boolean;
    abstract?: boolean;
}
interface SkillDefinition {
    cls: string;
    fun: MetaFunction;
    options: SkillOptions;
    impl: Function;
}
interface SkillOptions {
    subject?: string;
    action: string;
    background?: boolean;
    returns?: ValueType;
    form?: UiCard;
    displayRequest?: UiCard;
    displayResponse?: UiCard;
}
interface QuestionOptions {
    action: string;
    id?: string;
    background?: boolean;
    returns?: ValueType;
    form?: UiCard;
    displayQuestion?: UiCard;
    displayAnswer?: UiCard;
}
interface AnswerDefinition {
    cls: string;
    fun: MetaFunction;
    options: AnswerOptions;
    impl: Function;
}
interface AnswerOptions {
    id?: string;
    action: string;
    question?: Function;
    questionForm?: UiCard;
    displayQuestion?: UiCard;
    displayAnswer?: UiCard;
}
interface SkillRequestDefinition {
    cls: string;
    fun: MetaFunction;
    options: SkillRequestOptions;
    impl: Function;
}
interface SkillRequestOptions {
    subject: string;
    action: string;
    returns: ValueType;
}
interface ObserverOptions {
    subject: string;
    action: string;
}
interface FieldOptions {
    key?: 'new' | 'auto' | 'active' | 'destroy';
    hidden?: boolean;
    save?: boolean;
    restore?: boolean;
    optional?: boolean;
    type?: ValueType;
}
interface MetaFunction {
    name: string;
    parameters: MetaParameter[];
    conversation?: string;
    requester?: string;
    returnType?: ValueType;
}
interface MetaParameter {
    name: string;
    destructured: boolean;
    type: Function;
}
type ValueType = Function | Function[];

declare function makeRequest<T>(): Promise<T>;
declare function buildSkillRequest(skill: SkillRequestDefinition): (...args: any[]) => Promise<unknown>;
declare function handleSkillResponse(uid: string, body: object): void;

declare function InputType(): (cnstr: Function) => void;
declare function OutputType(): (cnstr: Function) => void;
declare function QuestionType(): (cnstr: Function) => void;
declare function SkillType(): (cnstr: Function) => void;
declare function StatusType(): (cnstr: Function) => void;
declare function finalizeDecorations(): void;
declare function Agent(options?: AgentOptions): (target: Function) => void;
declare function Field(options?: FieldOptions): (target: any, propertyKey: any) => void;
type ReturnTypeFunc = (returns?: void) => any;
declare function Skill(options: SkillOptions): (target: any, propertyKey: any, descriptor: any) => void;
declare function Loader(): (target: any, propertyKey: any, descriptor: any) => void;
declare function Question(options: QuestionOptions): (target: any, propertyKey: any, descriptor: any) => void;
declare function Answer(options: AnswerOptions): (target: any, propertyKey: any, descriptor: any) => void;
declare function SkillRequest(options: SkillRequestOptions): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => void;
declare function Observer(options: ObserverOptions): (target: any, propertyKey: any, descriptor: any) => void;

declare function getOrCreateConversation(id: string, agent: AgentDefinition, skill: SkillDefinition, answers: AnswerDefinition[]): Conversation;
declare function getConversation(cls: string, id: string): Conversation;
declare class ConversationInstance<T> {
    subject: string;
    action: string;
    agent: T;
}
declare class Conversation {
    id: string;
    recipientId: string;
    agent: AgentDefinition;
    skill: SkillDefinition;
    asks: Record<string, AnswerDefinition>;
    instance?: object;
    constructor(id: string);
    construct(agent: AgentDefinition, skill: SkillDefinition, answers: AnswerDefinition[]): void;
    ask(fun: Function, value: Record<string, any>): Promise<void>;
    status(type: Function, value: Record<string, any>): Promise<void>;
    response(value: any): Promise<void>;
}

interface RunAgentOptions {
    graphiqlEn?: boolean;
    testdrive?: boolean;
    port?: number;
}
declare function setCompileMode(): void;
declare function startAgent(opt?: RunAgentOptions): any;
declare function startAgent(inst: Object, opt?: RunAgentOptions): any;

declare class PlayReq {
    duration: number;
    speed: number;
    start_time: string;
}
declare abstract class SimAgent {
    simName: string;
    dataSource: stream.Readable;
    firstEventTime: Date;
    iterator: AsyncIterator<object>;
    localBaseTime: number;
    simBaseTime: number;
    simStopTime?: number;
    speed: number;
    done: boolean;
    paused: boolean;
    nextRecord: object;
    lastRecordTime: Date;
    lastPrint: number;
    recordCount: number;
    cancelRunLoop: Function;
    canceled: Promise<void>;
    constructor();
    started(): void;
    rollCall(): void;
    simPlay({ duration, speed, start_time }: PlayReq): void;
    simStop(): void;
    simReset(): void;
    registerSim(name: string, start_time: string): Promise<void>;
    signalStopped(name: string, stop_time: string): Promise<void>;
    signalFinished(name: string, end_time: string): Promise<void>;
    startSim(): Promise<void>;
    simInitSource(): Promise<void>;
    simRunLoop(): Promise<void>;
    waitUntil(dt: Date): Promise<void>;
    simWaitFor(ms: number): Promise<unknown>;
    advanceRecord(): Promise<void>;
    abstract createDataSource(): stream.Readable;
    abstract getNextTime(record?: object): Date | undefined;
    abstract step(record: object): any;
}

declare function CsvSource(istream: stream.Readable): stream.Transform;

export { Agent, Answer, Conversation, ConversationInstance, CsvSource, Field, InputType, Int, JsonValue, Loader, Observer, OutputType, Question, QuestionType, Requester, type ReturnTypeFunc, type RunAgentOptions, SimAgent, Skill, SkillRequest, SkillType, StatusType, Void, buildSkillRequest, finalizeDecorations, getConversation, getOrCreateConversation, handleSkillResponse, makeRequest, setCompileMode, startAgent };
